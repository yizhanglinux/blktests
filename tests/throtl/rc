#!/bin/bash
# SPDX-License-Identifier: GPL-3.0+
# Copyright (C) 2024 Yu Kuai
#
# Tests for blk-throttle

. common/rc
. common/null_blk
. common/scsi_debug
. common/cgroup

THROTL_DIR=$(echo "$TEST_NAME" | tr '/' '_')
THROTL_BLKDEV_TYPES=${THROTL_BLKDEV_TYPES:-"nullb sdebug"}
throtl_blkdev_type=${throtl_blkdev_type:-"nullb"}
THROTL_NULL_DEV=dev_nullb
declare THROTL_DEV
declare THROTL_CLEAR_BASE_SUBTREE_CONTROL_IO
declare THROTL_CLEAR_CGROUP2_DIR_CONTROL_IO

group_requires() {
	_have_root
	_have_null_blk
	_have_scsi_debug
	_have_kernel_option BLK_DEV_THROTTLING
	_have_cgroup2_controller io
	_have_program bc
}

_set_throtl_blkdev_type() {
	local index=$1
	local -a types

	read -r -a types <<< "${THROTL_BLKDEV_TYPES[@]}"

	if [[ -z $index ]]; then
		echo ${#types[@]}
		return
	fi

	throtl_blkdev_type=${types[index]}
	COND_DESC="${throtl_blkdev_type}"
}

# Prepare null_blk or scsi_debug device to test, based on throtl_blkdev_type.
_configure_throtl_blkdev() {
	local sector_size=0 memory_backed=0
	local -a args

	while [[ $# -gt 0 ]]; do
		case $1 in
			--sector_size)
				sector_size="$2"
				shift 2
				;;
			--memory_backed)
				memory_backed=1
				shift
				;;
			*)
				echo "WARNING: unknown argument: $1"
				shift
				;;
		esac
	done

	THROTL_DEV=
	case "$throtl_blkdev_type" in
	nullb)
		args=("$THROTL_NULL_DEV")
		((sector_size)) && args+=(max_sectors="$((sector_size / 512))")
		((memory_backed)) && args+=(memory_backed=1)
		if _configure_null_blk "${args[@]}" power=1; then
			THROTL_DEV=$THROTL_NULL_DEV
			return
		fi
		;;
	sdebug)
		args=(dev_size_mb=1024)
		((sector_size)) && args+=(sector_size="${sector_size}")
		if _configure_scsi_debug "${args[@]}"; then
			THROTL_DEV=${SCSI_DEBUG_DEVICES[0]}
			return
		fi
		;;
	*)
		echo "Invalid block device type: ${throtl_blkdev_type}" ;;
	esac
	return 1
}

_delete_throtl_blkdev() {
	case "$throtl_blkdev_type" in
	nullb)
		echo 0 > "/sys/kernel/config/nullb/$THROTL_DEV/power"
		;;
	sdebug)
		echo 1 > "/sys/block/$THROTL_DEV/device/delete"
		;;
	*)
		echo "Invalid block device type: ${throtl_blkdev_type}" ;;
	esac
}

_exit_throtl_blkdev() {
	case "$throtl_blkdev_type" in
	nullb)
		_exit_null_blk ;;
	sdebug)
		_exit_scsi_debug ;;
	*)
		echo "Invalid block device type: ${throtl_blkdev_type}" ;;
	esac
	unset THROTL_DEV
}

# Create a new null_blk device, and create a new blk-cgroup for test.
_set_up_throtl() {

	if ! _configure_throtl_blkdev "$@"; then
		return 1
	fi

	if ! _init_cgroup2; then
		_exit_throtl_blkdev
		return 1
	fi

	THROTL_CLEAR_BASE_SUBTREE_CONTROL_IO=
	THROTL_CLEAR_CGROUP2_DIR_CONTROL_IO=
	if ! grep -q io "$(_cgroup2_base_dir)/cgroup.subtree_control"; then
		echo "+io" > "$(_cgroup2_base_dir)/cgroup.subtree_control"
		THROTL_CLEAR_BASE_SUBTREE_CONTROL_IO=true
	fi
	if ! grep -q io "$CGROUP2_DIR/cgroup.subtree_control"; then
		echo "+io" > "$CGROUP2_DIR/cgroup.subtree_control"
		THROTL_CLEAR_CGROUP2_DIR_CONTROL_IO=true
	fi

	mkdir -p "$CGROUP2_DIR/$THROTL_DIR"
	return 0;
}

_clean_up_throtl() {
	rmdir "$CGROUP2_DIR/$THROTL_DIR"
	if [[ $THROTL_CLEAR_CGROUP2_DIR_CONTROL_IO == true ]]; then
		echo "-io" > "$CGROUP2_DIR/cgroup.subtree_control"
	fi
	if [[ $THROTL_CLEAR_BASE_SUBTREE_CONTROL_IO == true ]]; then
		echo "-io" > "$(_cgroup2_base_dir)/cgroup.subtree_control"
	fi

	_exit_cgroup2
	_exit_throtl_blkdev
}

_throtl_set_limits() {
	echo "$(cat /sys/block/"$THROTL_DEV"/dev) $*" > \
		"$CGROUP2_DIR/$THROTL_DIR/io.max"
}

_throtl_remove_limits() {
	echo "$(cat /sys/block/"$THROTL_DEV"/dev) rbps=max wbps=max riops=max wiops=max" > \
		"$CGROUP2_DIR/$THROTL_DIR/io.max"
}

_throtl_get_max_io_size() {
	cat "/sys/block/$THROTL_DEV/queue/max_sectors_kb"
}

_throtl_set_max_io_size() {
	echo "$1" > "/sys/block/$THROTL_DEV/queue/max_sectors_kb"
}

_throtl_issue_fs_io() {
	local path=$1
	local start_time
	local end_time
	local elapsed

	start_time=$(date +%s.%N)

	if [ "$2" == "read" ]; then
		dd if="${path}" of=/dev/null bs="$3" count="$4" iflag=direct status=none
	elif [ "$2" == "write" ]; then
		dd of="${path}" if=/dev/zero bs="$3" count="$4" oflag=direct conv=fdatasync status=none
	fi

	end_time=$(date +%s.%N)
	elapsed=$(echo "$end_time - $start_time" | bc)
	printf "%.0f\n" "$elapsed"
}

_throtl_issue_io() {
	local start_time
	local end_time
	local elapsed

	start_time=$(date +%s.%N)

	if [ "$1" == "read" ]; then
		dd if=/dev/"$THROTL_DEV" of=/dev/null bs="$2" count="$3" iflag=direct status=none
	elif [ "$1" == "write" ]; then
		dd of=/dev/"$THROTL_DEV" if=/dev/zero bs="$2" count="$3" oflag=direct status=none
	fi

	end_time=$(date +%s.%N)
	elapsed=$(echo "$end_time - $start_time" | bc)
	printf "%.0f\n" "$elapsed"
}

# Create an asynchronous thread and bind it to the specified blk-cgroup, issue
# IO and then print time elapsed to the second, blk-throttle limits should be
# set before this function.
_throtl_test_io() {

	{
		local rw=$1
		local bs=$2
		local count=$3

		echo "$BASHPID" > "$CGROUP2_DIR/$THROTL_DIR/cgroup.procs"
		_throtl_issue_io "$rw" "$bs" "$count"
	} &

	wait $!
}
